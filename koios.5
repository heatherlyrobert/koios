.TH koios 5 2016-May "linux" "structure of config, files, and streams"

.SH NAME
koios \- c language unit testing meta-language and parser

.SH PATRON (roughly pronounced key-oh-s)
.B koios-polos
(axis of heaven), titan of intelligence and farsight

.SH IMAGERY
northern star around which all the other consellations revolve

.SH SUMMARY
koios is a meta-language and related parser to simplify, standardize, and
make executable unit tests for the c language.  it is integrated with yUNIT,
yVAR, and oroborus (on a system-wide basis).

.SH DOCUMENTATION FILES
.nf  
koios (1)          command-line initiation, use, and options
.B koios (5)··········structure of config, files, and streams
koios (7)          decision rationale, scope, and objectives

.SH TABLE OF CONTENTS
.nf  
a) example         simple example of file contents
b) overview        general overview of unit test source
c) files           preview of files used and produced
d) units           guidelines for unit files
e) script          usage and layout of script-level verbs
f) condition       usage and layout of condition-level verbs
g) step            usage and layout of step-level verbs
h) specialty       usage and layout of specialty step verbs
i) oroborus        linkage to the oroborus sequencing system

.SH A) EXAMPLE
the following is a simplisic, but workable unit testing example.
the indentation of the first (or any) field is not required, but helps with
human comprehension and maintenance.  also, spacing and lining up fields is
also unnecessary, but clarifying ;)

below, the 
.B §
symbol is a placeholder for the ascii-standard 0x1F column separator.
0x1F must be used in a real file.

also, the
.B ´´´>
symbol means that more file contents exist to the right, but
are not shown in this example extract.

.B begin åexample.unitæ ---------------------------------

SCRP     § verify creation and destruction of object

  COND   § check initial state
    get  § check object count     § OBJ_count     §      ´´´>

  COND   § create first object    
    exec § call creation          § OBJ_create    §  32  ´´´>
    get  § check object count     § OBJ_count     §      ´´´>

  COND   § create second object   
    exec § call creation          § OBJ_create    §  60  ´´´>
    get  § check object count     § OBJ_count     §      ´´´>

  COND   § delete first object    
    exec § call destruction       § OBJ_delete    §  32  ´´´>
    get  § check object count     § OBJ_count     §      ´´´>

  COND   § purge all object       
    exec § call purge             § OBJ_purge     §      ´´´>
    get  § check object count     § OBJ_count     §      ´´´>

.B end åexample.unitæ -----------------------------------

.SH B) OVERVIEW
unit testing source files are kept in pure,
.B 8-bit ascii
text and a standard
.B column-delimited (0x1F)
format for very easy human digestion and maintenance using a programmer's
favorite editor.

for the sake of my environment and my standard make framework, each unit test
source file uses the
.B .unit
extension and begins with the common program prefix used by the related c
source files.

generally, but not necessarily, there is one unit test description file for
each source code file in the program.  some source may not require testing
(LOL) or may be broken into multiple testing files for easier maintenance.
additional files may be used for complex, integrated testing.

each line is complete in-and-of-itself, but they are executed sequentially
as they appear in the file.  preceding lines often establish conditions or
context for those that follow, but they are not explicitly linked.

vertically, unit tests have a
.B 4-level heirarchy
   1) unit         the entire file
   2) script       begin at
.B SCRP
and end before next
.B SCRP
   3) condition    begin at 
.B COND
and end before next
.B COND
   4) step         almost any other kind of line (almost)

horizontally, unit test lines roughly use a
.B 6-column layout
   1) verb         koios action requested
   2) description  human useful and shown on output
   3) function     actual c source function name
   4) arguments    arguments for that c function
   5) test         explained later and in yVAR
   6) expected     literal results of step/function

while not all lines follow this exact layout, columns are blocked out and spaced
to provide easy readability.  after intense editing, koios is fully capable
of re-formatting to keep a programmer from having to align everything manually.

.SH C) FILES
other than compilier artifacts, there are only four useful unit testing
files to consider.  there are no configuration files.

.B input files (human maintained) ----------------------------

.B åBASENAMEæ.unit
, the 8-bit, human-readable ascii text file that contains the unit testing
scripts.  this is editable in any editor and can be reformatted with
.B koios --convert åBASENAMEæ

.B master.unit
, an 8-bit, human-readable ascii text file with global code and execution
order descriptions useful to oroborus the unit test sequencer.  this is
not always useful.

.B outputs (do not edit) -------------------------------------

.B åBASENAMEæ_unit.c
, produced by
.B koios --update åBASENAMEæ
containing the c source code to be linked and compilied into the final unit
test.  this is temporarily useful and can normally be deleted.

.B åBASENAMEæ_unit
, also produced by
.B koios --update åBASENAMEæ
and is the compiled unit test which is linked to yUNIT and yVAR to display
standard unit testing results.

.SH UNITS
as described above, units are the contents of an entire
.B .unit
file.  during development, unit tests are typically executed script-by-script.
but, during production and updates, full units are often run.

there are two required, unit specific verbs...
   PREP       before any scripts, allows header inclusion
   incl       directly after PREP, includes one header each

.B begin åexample.unitæ ---------------------------------

PREP     § include the program headers    § 
   incl  § include public header          § example.h        §
   incl  § include private header         § example_priv.h   §

.B end åexample.unitæ -----------------------------------

no headers are automatically included, same as in c source files.  this is
the koios equivalent of
.B #include ¶example.h¶.

it is critical to get the
.B .unit
files (including master.unit, as needed) added to the version control system
as they are the equivelent of source code.

.B blank lines
have no meaning, but help with human comprehension.  these lines
are standardized during re-formatting and conversion.

.B #>
prefixed lines are kept as
.B comments
but moved to the top-of-file during re-formatting and conversion.

.SH SCRIPTS
scripts are just a grouping of conditions and execution lines into a manageable
and related set.  they are mostly a complexity management tool.

BUT, when using oroborus, scripts can be sequenced in complex ways to ensure
the correct testing order in large programs.

there are three script specific verbs...
   SCRP       starts the beginning of a new script
   SECT       allows scripts to be visually grouped in the output
   SHARED     unit-shared code that can be used in various scripts




.SH STRUCTURE

.B preparation (see PREPARATION)
   -- very first in the file and simply allows local header inclusion

.B fields
   -- each unit testing record is broken into 3 to 7 fields
   -- fields are separated by the ascii "field separator" character (31)
   -- fields may have leading and trailing spaces (which will be trimmed)
   -- best case is to use a columar format and indentation for readability

.B script level (see SCRIPTS)
   -- highest level structure in unit testing
   -- groups conditions into independent, runable chunks for ease of testing
   -- does no actual testing, this is simply a helpful organizing level
   -- produces reporting output to help visually review the unit test
   -- each script will produce summary numbers on successes and failures
   -- there may be one or more scripts in the file

.B conditions (see CONDITIONS)
   -- middle level structure in unit testing
   -- groups tests into logical blocks to verify a single objective
   -- does no actual testing, this is simply a helpful organizing level
   -- produces reporting output to help visually review the unit test
   -- each condition will produce summary numbers on successes and failures
   -- there may be one or more conditions in each script

.B steps
   -- bottom level structure in unit testing
   -- there may be one or more steps in each condition
   -- can be tests which execute functions directly (see TESTS)
   -- can be tests which compare to custom formatted strings (see CUSTOM)
   -- can be verification, or grey box testing (see GETTING)
   -- can be modification, also grey box testing (see SETTING)
   -- can be direct code injection (see CODE)
   -- can be system() calls to verify results (see SYSTEM)
   -- can be inserting records into stdin for later reading (see LOAD)
   -- can reverse the interpretation of pass and fail (see MODE)

.SH FIELDS
the field meanings in the file a "almost" totally standard.  the few exceptions
will be pointed out in the individual sections

.B verb
, 4-5 character label identifying the action of the script record

.B vers
, 3 character label to tell koios how the record is formatted.  examples are
v21, v20, and v19.

.B desc
, text field used literally to label output in the unit test.  while the fields
can be relatively long, only the first 40-60 characters are used in the output.
the trailing characters are truncated.

.B func
, the method/function to be called by the unit test.  this must be exactly right
or it will fail.

.B args
, the method/function arguments exactly as you would normally represent them.
you can use quoted strings, quoted characters, pointers, integers, reals, etc.
the key is you can also use local variables defined in "code" records.

.B test
, there are a large number of tests to compare the expected and actual results.
all these tests are defined in the man page for yVAR.

.B expe
, expected results as a string, so no quoting required.  if the test is
for integers or reals, the unit test will automatically convert using atoi,
atof respectively.

.SH SCRIPTS
it is way beyond the scope of this man page to describe current thinking
and best practices around the grouping of conditions into scripts.  but
this section will describe the formatting of a script record and the output
it produces.

.B fields (4)...
   1) verb    : SCRP
   2) vers    : (see FIELDS)
   3) desc    : (see FIELDS)
   4) func    : list just the major functions under review

.B sample script records...
   -- please replace double pipes (||) with the field sperator char (31)
   -- >> is used here as a line continuation symbol to show in man pages

   SCRP   || v20 || verify cronpulse operations            || >>
          >> BASE_timestamp, BASE_lastpulse                ||

.B sample output at the start of a script...
   -- a stark separator/divider is show to help visual review
   -- description and function fields are displayed (will trunc to fit)
   -- a consecutive script number is assigned to help selective execution
   -- source script line number is shown at the right to speed updates

   ===[[ NEW SCRIPT ]]======================================================
   SCRP [01] verify cronpulse operations ============================ [0019]
     focus : BASE_timestamp, BASE_lastpulse                                 

.B sample output at the end of a script...
   -- a summary line is printed at the end with useful numbers

   PRCS   step=43    [[ pass=43    fail=0     badd=0     void=0    ]]

.SH CONDITIONS
as with scripts, it is way beyond the scope of this man page to describe current
thinking and best practices around the grouping of tests into conditions.
but this section will describe the formatting of a condition record and the
output it produces.

.B fields (3)...
   1) verb    : COND
   2) vers    : (see FIELDS)
   3) desc    : (see FIELDS)

.B sample script records...
   -- please replace double pipes (||) with the field sperator char (31)
   -- >> is used here as a line continuation symbol to show in man pages

   COND   || v20 || test the cron ending time (cronwatch file)      ||

.B sample output at the start of a condition...
   -- the description is displayed on the single line (will trunc to fit)
   -- a consecutive condition number is assigned to help later review
   -- source condition line number is shown at the right to speed updates

   COND [008] test the cron ending time (cronwatch file) -- -- -- - [0294]

.B sample output at the end of a condition...
   -- a summary line is printed at the end with useful numbers

   DNOC   step=1     [[ pass=1     fail=0     badd=0     void=0    ]]

.SH TESTS
a test record executes a function and validates the return value against
an expected result.

.B fields (7)...
   1) verb    : exec
   2) vers    : (see FIELDS)
   3) desc    : (see FIELDS)
   4) func    : (see FIELDS)
   5) args    : (see FIELDS)
   6) test    : (see FIELDS)
   7) expe    : (see FIELDS)

.B sample script records...
   -- please replace double pipes (||) with the field sperator char (31)
   -- >> is used here as a line continuation symbol to show in man pages

   exec   || v20 || call the crontab name validation             || >>
          >> BASE_name      || "root.my_crontab"           , '-' || >>
          >> i_equal        || 0                                 ||

.B sample output...
   -- the description is displayed on the single line (will trunc to fit)
   -- arguments with double quotes are shown with tilda's instead
   -- a consecutive condition number is assigned to help later review
   -- source test line number is shown at the right to speed updates

   a ) PASS   : call the crontab name validation  .  .  .  .  .  .  [0348]
       method : BASE_name (~root.my_crontab~           , '-')
       test   : i_equal        (@ 0 msecs with rc = 21) 
       expect : 0>>
       actual : 0>>

.SH GETTING
getting is exactly the same as a "test" except is calls a unit test accessor
specifically used for greybox testing, i.e., limited access to internal state.
this ability is critical as most functions alter "something" like a method,
rather than only return a value like a function.

technically, this verb is not required and the information below simply
communicates how i personally conduct greybox testing.

use general "questions" so that the unit test is not dependent on internal
data representation or variable naming.

.B fields (7)...
   1) verb    : get
   -- rest are the same as in TEST section

.B sample script records...
   -- same as in TEST section

.B sample output...
   -- same as in TEST section

.B accessor questions...
   -- i personally call the accessors by the module the support
   -- i label them as a "getter", but you can call them anything you wish
   -- they take at least one string value, which is the question
   -- accessor code in a single function and indenpendent of the code
   -- the function included in the source code of the program itself

   prototype   : char   *BASE_getter   (char *a_question);

   sample call : BASE_getter ("sched_hrs");

.B global return value...
   -- use a single, globale, medium length c-string
   -- write answers from the accessor into a c-string
   -- name is anything you wish, i chose the name and length below

   char   *unit_answer   [1000];

.B answer formatting and sample output...
   -- make the answers unique to verify  the right accessor was used
   -- i chose to write formatted text into the strings
   -- i simply use snprintf to encase the value in the string
   -- do not make the strings reporting quality, only unique

   LIST hours       : [_____1__________________]

   LIST running     :    3 line,    2 fast,    0 proc

   LIST controls    : imp 0, mon -, cat -, del y, ski y, kil y

.B sample script records...
   -- please replace double pipes (||) with the field sperator char (31)
   -- >> is used here as a line continuation symbol to show in man pages

   get    || v20 || check hours                                || >>
          >> LIST_getter  || "sched_hrs"    , cfile_1st->tail  || >>
          >> s_equal      || LIST hours       : [_____1__________________]

.B sample output...
   -- the description is displayed on the single line (will trunc to fit)
   -- arguments with double quotes are shown with tilda's instead
   -- a consecutive condition number is assigned to help later review
   -- source test line number is shown at the right to speed updates

   l ) PASS   : check hours   (cursory)  .  .  .  .  .  .  .  .  .  [1316]
       method : LIST_unit (~sched_hrs~    , cfile_1st->tail)
       test   : s_equal        (@ 0 msecs with rc = 10) 
       expect : LIST hours       : [_____1__________________]>>
       actual : LIST hours       : [_____1__________________]>>

.SH SETTING
if changing internal state is required to properly test a program, i use
specific "setter" functions rather than change variables directly.  again,
this allows the program and data representation to change while not effecting
the unit test.

technically, this verb is not required and the information below simply
communicates how i personally conduct greybox testing.

.B fields (7)...
   1) verb    : set
   -- rest are the same as in TEST section

.B sample script records...
   -- same as in TEST section

.B sample output...
   -- same as in TEST section

.B example...
   -- for instance, sometimes i wish to reroute files to /tmp

   char       /*----: set up program test file locations --------------*/
   PROG_testfiles     (void)
   {
      snprintf (my.name_pulser , 200, "%s%s", "/tmp/" , FILE_PULSE);
      snprintf (my.name_watcher, 200, "%s%s", "/tmp/" , FILE_WATCH);
      snprintf (my.name_locker , 200, "%s%s", "/tmp/" , FILE_LOCK);
      snprintf (my.name_exec   , 200, "%s%s", "/tmp/" , FILE_EXEC);
      snprintf (my.name_status , 200, "%s%s", "/tmp/" , FILE_STATUS);
      return 0;
   }

.SH CUSTOM
to allow for compound and/or complicated expect strings, there is a global
string called CUSTOM.  actually, any string variable can be used, CUSTOM is
simply defined to make it easier.

.B add string to CUSTOM...
   -- first, sprintf is used to populate CUSTOM with a string

   code   || v21 || create a custom file expect string  || - - - || >>
          >> sprintf (CUSTOM, "LIST file list   : >>
          >> n=%4d, f=%4d, b=%4d, h=%-10p, t=%p", >>
          >> 2, 2, 2, cfile_1st, cfile_2nd);   ||

.B using string for a test...
   -- expect string has CUSTOM with double square brackets surrounding
   -- actually any string variable can be within the brackets
   -- this can be used with exec, get, and set

   get    || v21 || review the file list                       || >>
          >> LIST_unit    || "files"        , NULL             || >>
          >> s_equal      || [[ CUSTOM ]]                      ||

.SH CODE
in order to test, i always need some variables to hold values, pointers, etc.
to easily do this without a crazy number of script commands, i have simply
included a "code" script option to directly add code to the test.

.B fields (7)...
   1) verb    : exec
   2) vers    : (see FIELDS)
   3) desc    : (see FIELDS)
   4) func    : blank
   5) code    : see sample script records below

.B sample script records...
   -- please replace double pipes (||) with the field sperator char (31)
   -- >> is used here as a line continuation symbol to show in man pages

   code   || v21 || holder for broken-down time         || - - - || >>
          >> struct tm *curr_time = NULL;                        ||

.B sample output...
   -- the description is displayed on the single line (will trunc to fit)
   -- a consecutive test number is assigned to help later review
   -- source test line number is shown at the right to speed updates
   -- these do not count as test steps in the totals

   b ) CODE   : holder for broken-down time  .  .  .  .  .  .  .  . [0023]
       code   : struct tm *curr_time = NULL;                                          

.SH LOAD
if the program or a function reads data from stdin, the following verb will
load values for reading.

.B fields (7)...
   1) verb    : exec
   2) vers    : (see FIELDS)
   3) desc    : (see FIELDS)
   4) func    : blank
   5) payload : see script records below

.B sample script records...
   -- please replace double pipes (||) with the field sperator char (31)
   -- >> is used here as a line continuation symbol to show in man pages

   load   || v21 || add a basic line to stdin           || - - -          || >>
          >> * * * * * /bin/true > /dev/null                     ||

.B sample output...
   -- the description is displayed on the single line (will trunc to fit)
   -- a consecutive test number is assigned to help later review
   -- source test line number is shown at the right to speed updates
   -- these do not count as test steps in the totals

   a ) CODE   : add a basic line to stdin  .  .  .  .  .  .  .  .   [1000]
       load   : * * * * * /bin/true > /dev/null

.SH SYSTEM
sometimes the only way to verify a function is to understand its impact on
the linux environment itself.  there are many ways to accomplish this, but
one easy way is to run a system() call.

.B fields (7)...
   1) verb    : exec
   2) vers    : (see FIELDS)
   3) desc    : (see FIELDS)
   4) func    : blank
   5) payload : shell code

.B sample script records...
   -- please replace double pipes (||) with the field sperator char (31)
   -- >> is used here as a line continuation symbol to show in man pages

   sys    || v21 || get the filesystem owner            || - - - ||
          >> ls -l /tmp/themis/etc/themis.conf | cut -d' ' -f 3  ||

.B sample output...
   -- the description is displayed on the single line (will trunc to fit)
   -- a consecutive test number is assigned to help later review
   -- source test line number is shown at the right to speed updates
   -- these do not count as test steps in the totals

   d ) CODE   : get the filesystem perms  .  .  .  .  .  .  .  .  . [0453]
       sys    : ls -l /tmp/themis | grep etc | cut -d' ' -f 1

.SH MODE
rarely, but critically, sometimes it is valuable to force a failure just
to be sure of the results.  by this i mean, is the code just always labeling
everything a pass?  i am a little paranoid sometimes ;))

do not forget to turn the mode back to normal after testing.

.B fields (7)...
   1) verb    : mode
   2) vers    : (see FIELDS)
   3) desc    : blank
   4) func    : blank
   5) mode    : see below

.B sample script records...
   -- please replace double pipes (||) with the field sperator char (31)
   -- >> is used here as a line continuation symbol to show in man pages
   -- ther are only two options, "FORCED_FAIL" and "PASSING"

   mode   || v21 || set to failure mode                 || - - - || >>
          >>  "FORCED_FAIL"                                      ||

   mode   || v21 || set to normal mode                  || - - - || >>
          >>  "PASSING"                                          ||

.B effect...
   -- the shell pipeline is routed into the global yUNIT_systext
   -- you can the compare and test this value as you wish

.B sample output...
   -- the description is displayed on the single line (will trunc to fit)
   -- a consecutive test number is assigned to help later review
   -- source test line number is shown at the right to speed updates
   -- these do not count as test steps in the totals

   b ) MODE   : ENABLE FORCED FAILURE (pass=fail, fail=pass) .  .   [0530]

.SH PREPARATION
in order to properly compile, the unit test must have access to all local
headers.  this is a very easy, one-time step for the whole file, not script
by script.

.B sample script records...
   -- please replace double pipes (||) with the field sperator char (31)
   -- >> is used here as a line continuation symbol to show in man pages
   -- both lines below are required

   PREP   || v20 || include the prototype headers                ||

   incl   || v20 || include crond header           || khronos.h  ||

.B effect...
   -- "PREP" simply inserts some comments in the code
   -- "incl" intserts a #include directive in the code

.B sample output...
   -- none

.SH COMPILING
to work properly, the main function of the c program must be placed in
a separate source file.  i call mine by the [BASENAME]_main.c.  the unit
test creates its own main function within [BASENAME]_unit.c.  all program
modules (except main) need to be linked against [BASENAME]_unit.c to create
an executable.  i name the resulting executable [BASENAME]_unit.

.SH EXECUTING
the resulting [BASENAME]_unit executable has several options build in.

.B @@quiet
, no output only a return code : neg = fail, pos = warn, 0 = pass

.B @@test
, only a single line of summary numbers indicating pass/fail

.B @@scrp
, shows summary and script level output.  no step details

.B @@cond
, shows summary, script, and condition output. no step details.

.B @@step
, shows summary, script, and condition, and step output. no details.

.B @@full
, shows all output.  this is the default.

.B --console
, show plain text without terminal color codes.

.B --eterm
, show output with embedded eterm, 256 color terminal color codes.

.B <nn>
, two digits with a leading zero if required to make two.  this
causes the unit test to only run the script by that number.

.B <nnn>
, three digits with a leading zeros if required to make three.  this causes
the unit test to only show the condition by that number.  sometimes this
makes it easier to find in the output.

.SH BUGS and CONCERNS
koios depends on proper formatting of the input meta-language file.  if the
file lacks a double quote or delimiter in the correct place, the resulting
errors when compiling the c source for the unit test can be difficult to
track down.

.SH SEE ALSO
this documentation is layered to provide easier navigation.
   koios (7), decision rationale, objectives, and overview
   koios (5), structure of unit testing meta-language file
   koios (1), initiation, options, and structure
   yUNIT, unit testing support library
   yVAR, data comparison support library

.SH AUTHOR
rsheatherly  can be reached at jelloshrke at gmail dot com

.SH COLOPHON
this page is part of a documentation package mean to make the use of the
heatherly tools easier and faster
