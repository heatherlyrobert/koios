/*===============================[[ beg-code ]]===============================*/
#include    "koios.h"

#include    <yURG_solo.h>
#include    <yURG_uver.h>
#include    <yUNIT_solo.h>
#include    <ySTR_solo.h>
#include    <yCOLOR_solo.h>

char
koios_code_display (void)
{
   char         x_display  [LEN_RECD]  = "";
   char         x_system   [LEN_RECD]  = "";
   char         x_load     [LEN_RECD]  = "";

   yUNIT_minscrpy ("koios", "koios_code", "(CODE) verify display string");
   PROG__unit_quiet  ();

   yUNIT_mincond  ("verify quick success");
   yUNIT_minval   ("convert code"                       , CODE__display    ("a = 5;"                                                             , x_display, x_system , x_load   ),    0);
   yUNIT_minstr   ("... check display"                  , x_display     , "a = 5;");
   yUNIT_minstr   ("... check system"                   , x_system      , "a = 5;");
   yUNIT_minstr   ("... check load"                     , x_load        , "a = 5;");
   yUNIT_mindnoc  ();

   yUNIT_mincond  ("verify field and group markers");
   yUNIT_minval   ("convert code"                       , CODE__display    ("verb Д field е 123 Д"                                               , x_display, x_system , x_load   ),    0);
   yUNIT_minstr   ("... check display"                  , x_display     , "verb Д field е 123 Д");
   yUNIT_minstr   ("... check system"                   , x_system      , "verb  field  123 ");
   yUNIT_minstr   ("... check load"                     , x_load        , "verb  field  123 ");
   yUNIT_mindnoc  ();

   yUNIT_mincond  ("verify extended characters");
   yUNIT_minval   ("convert code"                       , CODE__display    ("┤ и │ « а ж █ і"                                                    , x_display, x_system , x_load   ),    0);
   yUNIT_minstr   ("... check display"                  , x_display     , "┤ и │ « а ж █ і");
   yUNIT_minstr   ("... check system"                   , x_system      , "┤ и │ « а ж █ і");
   yUNIT_minstr   ("... check load"                     , x_load        , "┤ и │ « а ж █ і");
   yUNIT_mindnoc  ();

   yUNIT_mincond  ("verify quotes");
   yUNIT_minval   ("convert code"                       , CODE__display    ("the \"quoted\" text"                                                , x_display, x_system , x_load   ),    0);
   yUNIT_minstr   ("... check display"                  , x_display     , "the ХquotedХ text");
   yUNIT_minstr   ("... check system"                   , x_system      , "the \"quoted\" text");
   yUNIT_minstr   ("... check load"                     , x_load        , "the ~quoted~ text");
   yUNIT_mindnoc  ();

   yUNIT_mincond  ("verify returns and escapes");
   yUNIT_minval   ("convert code"                       , CODE__display    (":macro\n or д and \e end or Ц"                                      , x_display, x_system , x_load   ),    0);
   yUNIT_minstr   ("... check display"                  , x_display     , ":macroд or д and Ц end or Ц");
   yUNIT_minstr   ("... check system"                   , x_system      , ":macro\\n or д and \\e end or Ц");
   yUNIT_minstr   ("... check load"                     , x_load        , ":macro\\n or д and \\e end or Ц");
   yUNIT_mindnoc  ();

   PROG__unit_end    ();
   yUNIT_minprcs  ();
   return 0;
}

char
koios_code_prefix  (void)
{
   char         x_name     [LEN_HUND] = "/tmp/apate.c";
   FILE        *x_file     = NULL;
   char         x_display  [LEN_RECD]  = "";
   char         x_system   [LEN_RECD]  = "";
   char         x_load     [LEN_RECD]  = "";
   char         t          [LEN_HUND] = "";

   yUNIT_minscrpy ("koios", "koios_code", "(CODE) verify prefix string");
   PROG__unit_quiet  ();

   sprintf (t, "rm -f %s 2> /dev/null", x_name);
   system (t);
   yUNIT_mincond ("prepare clean start");
   yUNIT_mindnoc ();

   yUNIT_mincond  ("open code file");
   yUNIT_minpoint ("open file"                          , x_file = fopen (x_name, "wt"), 1);
   yUNIT_mindnoc  ();

   yUNIT_mincond  ("verify quick success (string)");
   yUNIT_minval   ("convert code"                       , CODE__display    ("\"arguments\""                                                    , x_display, x_system , x_load   ),    0);
   yUNIT_minval   ("write prefix code"                  , CODE__prefix     (x_file    , "exec"    , "call the function"   , "DITTO_parse"    , "s_equal"   , x_display, x_system , '-',   0,   0),    0);
   CONV_printf   (x_file, "\n");
   fflush (x_file);
   yUNIT_minstr   ("... header"                         , yURG_upeek       (x_name    ,   0)      , "      yUNIT_reset_rc ();"                 );
   yUNIT_minstr   ("... header"                         , yURG_upeek       (x_name    ,   1)      , "      if (cyUNIT.exec)  cyUNIT.s_rc = DITTO_parse (\"arguments\");");
   yUNIT_minstr   ("... header"                         , yURG_upeek       (x_name    ,   2)      , "      yUNIT_string  (   0,   0, \"call the function\", \"DITTO_parse\", \"ХargumentsХ\", \"s_equal\", ");
   yUNIT_minstr   ("... header"                         , yURG_upeek       (x_name    ,   3)      , "(n/a)"                                    );
   yUNIT_mindnoc  ();

   yUNIT_mincond  ("verify a void");
   yUNIT_minval   ("convert code"                       , CODE__display    ("15, 67"                                                           , x_display, x_system , x_load   ),    0);
   yUNIT_minval   ("write prefix code"                  , CODE__prefix     (x_file    , "exec"    , "deal with a void"    , "MAIN_driver"    , "v_void"    , x_display, x_system , '-',   0,   0),    0);
   fflush (x_file);
   yUNIT_minstr   ("... header"                         , yURG_upeek       (x_name    ,   3)      , "      yUNIT_reset_rc ();"                 );
   yUNIT_minstr   ("... header"                         , yURG_upeek       (x_name    ,   4)      , "      if (cyUNIT.exec)  MAIN_driver (15, 67);");
   yUNIT_minstr   ("... header"                         , yURG_upeek       (x_name    ,   5)      , "      yUNIT_void    (   0,   0, \"deal with a void\", \"MAIN_driver\", \"15, 67\", \"v_void\", cyUNIT.exec);");
   yUNIT_minstr   ("... header"                         , yURG_upeek       (x_name    ,   6)      , "(n/a)"                                    );
   yUNIT_mindnoc  ();

   yUNIT_mincond  ("verify an integer");
   yUNIT_minval   ("convert code"                       , CODE__display    ("3"                                                                , x_display, x_system , x_load   ),    0);
   yUNIT_minval   ("write prefix code"                  , CODE__prefix     (x_file    , "exec"    , "cube a number"       , "cube"           , "i_equal"   , x_display, x_system , '-',   0,   0),    0);
   CONV_printf   (x_file, "\n");
   fflush (x_file);
   yUNIT_minstr   ("... header"                         , yURG_upeek       (x_name    ,   6)      , "      yUNIT_reset_rc ();"                 );
   yUNIT_minstr   ("... header"                         , yURG_upeek       (x_name    ,   7)      , "      if (cyUNIT.exec)  cyUNIT.i_rc = cube (3);");
   yUNIT_minstr   ("... header"                         , yURG_upeek       (x_name    ,   8)      , "      yUNIT_int     (   0,   0, \"cube a number\", \"cube\", \"3\", \"i_equal\", ");
   yUNIT_minstr   ("... header"                         , yURG_upeek       (x_name    ,   9)      , "(n/a)"                                    );
   yUNIT_mindnoc  ();

   yUNIT_mincond  ("open code file");
   yUNIT_minval   ("close file"                         , READ_close  (&x_file), 0);
   yUNIT_mindnoc  ();

   PROG__unit_end    ();
   yUNIT_minprcs  ();
   return 0;
}

char
koios_code_expect  (void)
{
   char         x_name     [LEN_HUND] = "/tmp/apate.c";
   FILE        *x_file     = NULL;
   char         x_display  [LEN_RECD]  = "";
   char         x_system   [LEN_RECD]  = "";
   char         x_load     [LEN_RECD]  = "";
   char         t          [LEN_HUND]  = "";

   yUNIT_minscrpy ("koios", "koios_code", "(CODE) verify expect string");
   PROG__unit_quiet  ();

   sprintf (t, "rm -f %s 2> /dev/null", x_name);
   system (t);
   yUNIT_mincond ("prepare clean start");
   yUNIT_mindnoc ();

   yUNIT_mincond  ("open code file");
   yUNIT_minval   ("open the code file"                 , READ_open   (x_name, 'w', &x_file, NULL   ),    0);
   yUNIT_mindnoc  ();

   yUNIT_mincond  ("verify quick success (string)");
   yUNIT_minval   ("write expect code"                  , CODE__expect     (x_file    , "s_equal"   , "expected result"         ),    1);
   CONV_printf   (x_file, "\n");
   fflush (x_file);
   yUNIT_minstr   ("... header"                         , yURG_upeek       (x_name    ,   0)      , "\"expected result\", "                    );
   yUNIT_minstr   ("... header"                         , yURG_upeek       (x_name    ,   1)      , "(n/a)"                                    );
   yUNIT_mindnoc  ();

   yUNIT_mincond  ("verify void does nothing");
   yUNIT_minval   ("write expect code"                  , CODE__expect     (x_file    , "v_void"    , ""                        ),    0);
   fflush (x_file);
   yUNIT_minstr   ("... header"                         , yURG_upeek       (x_name    ,   1)      , "(n/a)"                                    );
   yUNIT_mindnoc  ();

   yUNIT_mincond  ("verify pointer");
   yUNIT_minval   ("write expect code"                  , CODE__expect     (x_file    , "p_exists"  , "0x123456"                ),    1);
   CONV_printf   (x_file, "\n");
   fflush (x_file);
   yUNIT_minstr   ("... header"                         , yURG_upeek       (x_name    ,   1)      , "0x123456, "                               );
   yUNIT_minstr   ("... header"                         , yURG_upeek       (x_name    ,   2)      , "(n/a)"                                    );
   yUNIT_mindnoc  ();

   yUNIT_mincond  ("verify matching variable");
   yUNIT_minval   ("write expect code"                  , CODE__expect     (x_file    , "any"       , "[[ x_var ]]"             ),    2);
   CONV_printf   (x_file, "\n");
   fflush (x_file);
   yUNIT_minstr   ("... header"                         , yURG_upeek       (x_name    ,   2)      , "x_var, "                                  );
   yUNIT_minstr   ("... header"                         , yURG_upeek       (x_name    ,   3)      , "(n/a)"                                    );
   yUNIT_mindnoc  ();

   yUNIT_mincond  ("open code file");
   yUNIT_minval   ("close the script file"              , READ_close  (&x_file)                 , 0);
   yUNIT_mindnoc  ();

   PROG__unit_end    ();
   yUNIT_minprcs  ();
   return 0;
}

char
koios_code_suffix  (void)
{
   char         x_name     [LEN_HUND] = "/tmp/apate.c";
   FILE        *x_file     = NULL;
   char         x_display  [LEN_RECD]  = "";
   char         x_system   [LEN_RECD]  = "";
   char         x_load     [LEN_RECD]  = "";
   char         t          [LEN_HUND]  = "";

   yUNIT_minscrpy ("koios", "koios_code", "(CODE) verify suffix string");
   PROG__unit_quiet  ();

   sprintf (t, "rm -f %s 2> /dev/null", x_name);
   system (t);
   yUNIT_mincond ("prepare clean start");
   yUNIT_mindnoc ();

   yUNIT_mincond  ("open code file");
   yUNIT_minval   ("open the code file"                 , READ_open   (x_name, 'w', &x_file, NULL   ),    0);
   yUNIT_mindnoc  ();

   yUNIT_mincond  ("verify quick success (string)");
   yUNIT_minval   ("write suffix code"                  , CODE__suffix     (x_file    , "exec"    , "s_equal"   , ""                        , ""          ),    1);
   fflush (x_file);
   yUNIT_minstr   ("... check line"                     , yURG_upeek       (x_name    ,   0)      , "cyUNIT.s_rc, cyUNIT.exec);"               );
   yUNIT_minstr   ("... check line"                     , yURG_upeek       (x_name    ,   1)      , "(n/a)"                                    );
   yUNIT_mindnoc  ();

   yUNIT_mincond  ("verify string with return");
   yUNIT_minval   ("write suffix code"                  , CODE__suffix     (x_file    , "exec"    , "s_equal"   , ""                        , "x_str"     ),    1);
   fflush (x_file);
   yUNIT_minstr   ("... check line"                     , yURG_upeek       (x_name    ,   1)      , "cyUNIT.s_rc, cyUNIT.exec);"               );
   yUNIT_minstr   ("... check line"                     , yURG_upeek       (x_name    ,   2)      , "      if (cyUNIT.exec) { if (cyUNIT.s_rc != NULL)  strcpy (x_str, cyUNIT.s_rc); else strcpy (x_str, \"\"); }");
   yUNIT_minstr   ("... check line"                     , yURG_upeek       (x_name    ,   3)      , "(n/a)"                                    );
   yUNIT_mindnoc  ();

   yUNIT_mincond  ("verify void does nothing");
   yUNIT_minval   ("write suffix code"                  , CODE__suffix     (x_file    , "exec"    , "v_void"    , ""                        , ""          ),    0);
   fflush (x_file);
   yUNIT_minstr   ("... check line"                     , yURG_upeek       (x_name    ,   3)      , "(n/a)"                                    );
   yUNIT_mindnoc  ();

   yUNIT_mincond  ("verify integer with return");
   yUNIT_minval   ("write suffix code"                  , CODE__suffix     (x_file    , "exec"    , "i_equal"   , ""                        , "n"         ),    1);
   fflush (x_file);
   yUNIT_minstr   ("... check line"                     , yURG_upeek       (x_name    ,   3)      , "cyUNIT.i_rc, cyUNIT.exec);"               );
   yUNIT_minstr   ("... check line"                     , yURG_upeek       (x_name    ,   4)      , "      if (cyUNIT.exec)  n = cyUNIT.i_rc;" );
   yUNIT_minstr   ("... check line"                     , yURG_upeek       (x_name    ,   5)      , "(n/a)"                                    );
   yUNIT_mindnoc  ();

   yUNIT_mincond  ("open code file");
   yUNIT_minval   ("close the script file"              , READ_close  (&x_file)                 , 0);
   yUNIT_mindnoc  ();

   PROG__unit_end    ();
   yUNIT_minprcs  ();
   return 0;
}

char
koios_code_preps   (void)
{
   char         x_nscrp    [LEN_HUND]  = "/tmp/apate.unit";
   char         x_nmain    [LEN_HUND]  = "/tmp/apate_unit.tmp";
   FILE        *x_main     = NULL;
   char         x_ncode    [LEN_HUND]  = "/tmp/apate.c";
   FILE        *x_code     = NULL;
   char         x_nwave    [LEN_HUND]  = "/tmp/apate.wave";
   FILE        *x_wave     = NULL;
   char         t          [LEN_HUND]  = "";
   char         x_cshare   =  '-';

   yUNIT_minscrpy ("koios", "koios_code", "(CODE) verify header and footer");
   PROG__unit_quiet  ();

   yUNIT_mincond  ("open the files");
   yUNIT_minpoint ("open file"                          , x_main = fopen (x_nmain, "wt"), 1);
   yUNIT_minpoint ("open file"                          , x_code = fopen (x_ncode, "wt"), 1);
   yUNIT_mindnoc  ();

   yUNIT_mincond  ("verify writing a code beg");
   yUNIT_minval   ("write code beg"                     , CODE__code_beg  (x_nscrp, x_code)   ,    0);
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   ,   0)      , "/*================================= beg-code =================================*/");
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "/* /usr/local/bin/koios                                                       */");
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "/*   autogen by koios-polos (axis of heaven) unit testing meta-language       */");
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , ""                                                                                );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "/*---(standard support functions)----*/"                                         );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "#include    <yUNIT_unit.h>"                                                      );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "#include    \"master.h\""                                                        );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , ""                                                                                );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "/*================================ beg-script ================================*/");
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "(n/a)"                                                                           );
   yUNIT_mindnoc  ();

   yUNIT_mincond  ("verify writing a code stats");
   yUNIT_minval   ("write code stats"                   , CODE__code_stats  (x_code) ,    0);
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   ,   9)      , ""                                                                                );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "char"                                                                            );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "yUNIT_stats     (void)"                                                          );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "{"                                                                               );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "   yUNIT_unique (0, 0, 0, 0, 0, 0);"                                             );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "   return 0;"                                                                    );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "}"                                                                               );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , ""                                                                                );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "(n/a)"                                                                           );
   yUNIT_mindnoc  ();

   yUNIT_mincond  ("verify writing a code end");
   yUNIT_minval   ("write code end"                     , CODE__code_end  (x_nscrp, x_code)   ,    0);
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   ,  17)      , ""                                                                                );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "/*================================ end-script ================================*/");
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "(n/a)"                                                                           );
   yUNIT_mindnoc  ();

   yUNIT_mincond  ("verify writing a main beg");
   yUNIT_minval   ("write main beg"                     , CODE__main_beg  (x_main, x_nscrp)  ,    0);
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_nmain   ,   0)      , ""                                                                                );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_nmain   , 'о')      , ""                                                                                );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_nmain   , 'о')      , ""                                                                                );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_nmain   , 'о')      , "int"                                                                             );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_nmain   , 'о')      , "main                    (int a_argc, char *a_argv[])"                            );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_nmain   , 'о')      , "{"                                                                               );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_nmain   , 'о')      , "   /*---(locals)-----------+-----+-----+-*/"                                     );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_nmain   , 'о')      , "   int         rc          =    0;"                                              );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_nmain   , 'о')      , "   /*---(prepare)------------------------*/"                                     );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_nmain   , 'о')      , "   rc = yUNIT_init ();"                                                          );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_nmain   , 'о')      , "   rc = yUNIT_args (a_argc, a_argv);"                                            );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_nmain   , 'о')      , "   if (rc < 0)  return -1;"                                                      );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_nmain   , 'о')      , "   yUNIT_unit (\"/tmp/apate\", cyUNIT.level, cyUNIT.eterm, cyUNIT.exec);"             );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_nmain   , 'о')      , "   /*---(beg scripts)--------------------*/"                                     );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_nmain   , 'о')      , "(n/a)"                                                                           );
   yUNIT_mindnoc  ();

   yUNIT_mincond  ("verify writing a main end");
   yUNIT_minval   ("write main end"                     , CODE__main_end  (x_main)   ,    0);
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_nmain   ,  14)      , "   /*---(end scripts)--------------------*/"                                     );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_nmain   , 'о')      , "   rc = yUNIT_tinu (cyUNIT.exec);"                                               );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_nmain   , 'о')      , "   /*---(complete)-----------------------*/"                                     );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_nmain   , 'о')      , "   return rc;"                                                                   );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_nmain   , 'о')      , "}"                                                                               );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_nmain   , 'о')      , ""                                                                                );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_nmain   , 'о')      , ""                                                                                );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_nmain   , 'о')      , ""                                                                                );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_nmain   , 'о')      , "/* end-of-file.  done, finito, completare, whimper [¤┤иии                     */");
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_nmain   , 'о')      , "/*================================= end-code =================================*/");
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_nmain   , 'о')      , "(n/a)"                                                                           );
   yUNIT_mindnoc  ();

   yUNIT_mincond  ("close the files");
   yUNIT_minval   ("close main"                         , READ_close  (&x_main), 0);
   sprintf (t, "rm -f %s   2> /dev/null", x_nmain);  system (t);
   yUNIT_minval   ("close code"                         , READ_close  (&x_code), 0);
   sprintf (t, "rm -f %s   2> /dev/null", x_ncode);  system (t);
   yUNIT_mindnoc  ();

   yUNIT_mincond  ("verify calling the header");
   yUNIT_minpoint ("... check main pointer"              , x_main        , 0x0);
   yUNIT_minpoint ("... check code pointer"              , x_code        , 0x0);
   yUNIT_minpoint ("... check wave pointer"              , x_wave        , 0x0);
   yUNIT_minval   ("call header"                        , CODE_header     (x_nscrp, x_nmain, &x_main, x_ncode, &x_code, x_nwave, &x_wave, &x_cshare),    0);
   yUNIT_minpoint ("... check main pointer"              , x_main        , 0x1);
   yUNIT_minpoint ("... check code pointer"              , x_code        , 0x1);
   yUNIT_minpoint ("... check wave pointer"              , x_wave        , 0x1);
   yUNIT_mindnoc  ();

   yUNIT_mincond  ("verify the CODE output");
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   ,   0)      , "/*================================= beg-code =================================*/");
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "/* /usr/local/bin/koios                                                       */");
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "/*   autogen by koios-polos (axis of heaven) unit testing meta-language       */");
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , ""                                                                                );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "/*---(standard support functions)----*/"                                         );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "#include    <yUNIT_unit.h>"                                                      );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "#include    \"master.h\""                                                        );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , ""                                                                                );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "/*================================ beg-script ================================*/");
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "(n/a)"                                                                           );
   yUNIT_mindnoc  ();

   yUNIT_mincond  ("verify the MAIN output");
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_nmain   ,   0)      , ""                                                                                );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_nmain   , 'о')      , ""                                                                                );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_nmain   , 'о')      , ""                                                                                );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_nmain   , 'о')      , "int"                                                                             );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_nmain   , 'о')      , "main                    (int a_argc, char *a_argv[])"                            );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_nmain   , 'о')      , "{"                                                                               );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_nmain   , 'о')      , "   /*---(locals)-----------+-----+-----+-*/"                                     );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_nmain   , 'о')      , "   int         rc          =    0;"                                              );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_nmain   , 'о')      , "   /*---(prepare)------------------------*/"                                     );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_nmain   , 'о')      , "   rc = yUNIT_init ();"                                                          );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_nmain   , 'о')      , "   rc = yUNIT_args (a_argc, a_argv);"                                            );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_nmain   , 'о')      , "   if (rc < 0)  return -1;"                                                      );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_nmain   , 'о')      , "   yUNIT_unit (\"/tmp/apate\", cyUNIT.level, cyUNIT.eterm, cyUNIT.exec);"             );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_nmain   , 'о')      , "   /*---(beg scripts)--------------------*/"                                     );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_nmain   , 'о')      , "(n/a)"                                                                           );
   yUNIT_mindnoc  ();

   yUNIT_mincond  ("verify calling the footer");
   yUNIT_minval   ("call footer"                        , CODE_footer     ('y', x_nscrp, x_nmain, &x_main, x_ncode, &x_code, x_nwave, &x_wave, '-'),    0);
   yUNIT_minpoint ("... check main pointer"              , x_main        , 0x0);
   yUNIT_minpoint ("... check code pointer"              , x_code        , 0x0);
   yUNIT_minpoint ("... check wave pointer"              , x_wave        , 0x0);

   yUNIT_mincond  ("verify writing a code stats");
   yUNIT_minval   ("write code stats"                   , CODE__code_stats  (x_code) ,    0);
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   ,   9)      , ""                                                                                );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "/*================================ end-script ================================*/");
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , ""                                                                                );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "char"                                                                            );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "yUNIT_stats     (void)"                                                          );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "{"                                                                               );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "   yUNIT_unique (0, 0, 0, 0, 0, 0);"                                             );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "   return 0;"                                                                    );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "}"                                                                               );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , ""                                                                                );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , ""                                                                                );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "char"                                                                            );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "yUNIT_verbs (void)"                                                              );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "{"                                                                               );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "   printf (\"koios, record type summary\\n\");"                                  );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "   printf (\"\\noverall...\\n\");"                                               );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "   printf (\"  PREP       =     0   preparation before testing\\n\");"           );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "   printf (\"  incl       =     0   c header inclusion\\n\");"                   );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "   printf (\"  #>         =     0   script internal comments\\n\");"             );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "   printf (\"\\nscripts...\\n\");"                                               );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "   printf (\"  SCRP       =     0   test script header\\n\");"                   );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "   printf (\"  SHARED     =     0   shared code between scripts\\n\");"          );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "   printf (\"  GLOBAL     =     0   shared code between units\\n\");"            );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "   printf (\"  SECT       =     0   grouping of scripts\\n\");"                  );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "   printf (\"\\nconditions...\\n\");"                                            );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "   printf (\"  COND       =     0   test condition\\n\");"                       );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "   printf (\"  DITTO      =     0   repeated test condition\\n\");"              );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "   printf (\"  REUSE      =     0   inclusion of shared code\\n\");"             );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "   printf (\"  GROUP      =     0   grouping of conditions\\n\");"               );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "   printf (\"\\nvariables...\\n\");"                                             );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "   printf (\"  global     =     0   global/unit variable definition\\n\");"      );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "   printf (\"  local      =     0   local/script variable definition\\n\");"     );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "   printf (\"\\nsteps...\\n\");"                                                 );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "   printf (\"  exec       =     0   function execution\\n\");"                   );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "   printf (\"  get        =     0   unit test accessor retrieval\\n\");"         );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "   printf (\"  echo       =     0   test a variable directly\\n\");"             );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "   printf (\"\\nspecialty...\\n\");"                                             );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "   printf (\"  code       =     0   insert c code\\n\");"                        );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "   printf (\"  system     =     0   execute shell code\\n\");"                   );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "   printf (\"  load       =     0   place data into input\\n\");"                );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "   printf (\"  mode       =     0   set pass or forced_fail mode\\n\");"         );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "   printf (\"\\nsupport...\\n\");"                                               );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "   printf (\"  file       =     0   create a temporary file\\n\");"              );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "   printf (\"  append     =     0   append data to temporary file\\n\");"        );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "   printf (\"\\noroboros...\\n\");"                                              );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "   printf (\"  WAVE       =     0   testing wave definition\\n\");"              );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "   printf (\"  stage      =     0   testing stage definition\\n\");"             );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "   printf (\"\\nend-of-entries...\\n\");"                                        );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "   printf (\"TOTAL        =     0   count of all verb use\\n\");"                );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "   printf (\"concerns     =     0   records with troubles\\n\");"                );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "   return 0;"                                                                    );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "}"                                                                               );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , ""                                                                                );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , ""                                                                                );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , ""                                                                                );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , ""                                                                                );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "int"                                                                             );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "main                    (int a_argc, char *a_argv[])"                            );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "{"                                                                               );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "   /*---(locals)-----------+-----+-----+-*/"                                     );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "   int         rc          =    0;"                                              );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "   /*---(prepare)------------------------*/"                                     );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "   rc = yUNIT_init ();"                                                          );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "   rc = yUNIT_args (a_argc, a_argv);"                                            );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "   if (rc < 0)  return -1;"                                                      );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "   yUNIT_unit (\"/tmp/apate\", cyUNIT.level, cyUNIT.eterm, cyUNIT.exec);"             );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "   /*---(beg scripts)--------------------*/"                                     );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "   /*---(end scripts)--------------------*/"                                     );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "   rc = yUNIT_tinu (cyUNIT.exec);"                                               );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "   /*---(complete)-----------------------*/"                                     );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "   return rc;"                                                                   );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "}"                                                                               );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , ""                                                                                );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , ""                                                                                );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , ""                                                                                );
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "/* end-of-file.  done, finito, completare, whimper [¤┤иии                     */");
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "/*================================= end-code =================================*/");
   yUNIT_minstr   ("... check result"                   , yURG_upeek      (x_ncode   , 'о')      , "(n/a)"                                                                           );
   yUNIT_mindnoc  ();

   PROG__unit_end    ();
   yUNIT_minprcs  ();
   return 0;
}

char
koios_code_scrp    (void)
{
   char         x_nmain    [LEN_HUND] = "/tmp/other.c";
   FILE        *x_main     = NULL;
   char         x_nfile    [LEN_HUND] = "/tmp/apate.c";
   FILE        *x_file     = NULL;
   char         x_nwave    [LEN_HUND] = "/tmp/apate.wave";
   FILE        *x_wave     = NULL;
   char         x_cshare   =  '-';
   char         t          [LEN_HUND]  = "";

   yUNIT_minscrpy ("koios", "koios_code", "(CODE) verify script level entries");
   PROG__unit_quiet  ();


   sprintf (t, "rm -f %s 2> /dev/null", x_nmain);
   system (t);
   sprintf (t, "rm -f %s 2> /dev/null", x_nfile);
   system (t);
   sprintf (t, "rm -f %s 2> /dev/null", x_nwave);
   system (t);
   yUNIT_mincond ("prepare clean start");
   yUNIT_minval   ("clear statistics"                   , CODE_init   (),    0);
   yUNIT_mindnoc ();

   yUNIT_mincond  ("open files");
   yUNIT_minval   ("open the main file"                 , READ_open   (x_nmain          , 'w', &x_main, NULL   ),    0);
   yUNIT_minval   ("open the code file"                 , READ_open   (x_nfile          , 'w', &x_file, NULL   ),    0);
   yUNIT_minval   ("open the wave file"                 , READ_open   (x_nwave          , 'w', &x_wave, NULL   ),    0);
   yUNIT_mindnoc  ();

   yUNIT_mincond  ("verify writing a SCRP (before anything else)");
   yUNIT_minval   ("write code line"                    , CODE_scrp      (x_nfile   , x_main    , x_file    , x_wave    , G_RUN_CREATE, "----", "SCRP"  , "first testing"       , ""               , ""               , ""          , ""               , ""          , "0a" , '-', '-', '-',   0,   0, '-', &x_cshare),    0);
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_nfile   ,   0)      , ""                                           );
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_nfile   , 'о')      , "char"                                       );
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_nfile   , 'о')      , "yUNIT_script_01          (void)"            );
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_nfile   , 'о')      , "{"                                          );
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_nfile   , 'о')      , "   /*===[[ script header ]]========================*/");
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_nfile   , 'о')      , "   cyUNIT.offset  = 0;"                     );
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_nfile   , 'о')      , "   cyUNIT.origin  = 1;"                     );
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_nfile   , 'о')      , "   yUNIT_mode_reset ();"                    );
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_nfile   , 'о')      , "   yUNIT_scrp    (   0,   1, \"0a\", \"first testing\", \"\", \"\", \"\");");
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_nfile   , 'о')      , "(n/a)"                                      );
   yUNIT_mindnoc  ();

   yUNIT_mincond  ("verify writing to MAIN file)");
   yUNIT_minstr   ("... check MAIN"                     , yURG_upeek     (x_nmain   ,   0)   , "   if (yUNIT_run_scrp ( 1) == 1)  yUNIT_script_01 ();");
   yUNIT_minstr   ("... check MAIN"                     , yURG_upeek     (x_nmain   , 'о')   , "(n/a)"                                      );
   yUNIT_mindnoc  ();

   yUNIT_mincond  ("verify writing to WAVE file)");
   yUNIT_minstr   ("... check WAVE"                     , yURG_upeek     (x_nwave   , '0')   , "(n/a)"                                      );
   yUNIT_mindnoc  ();

   yUNIT_mincond  ("verify writing an COND");
   yUNIT_minval   ("write code line"                    , CODE_cond      (x_nfile   , x_main    , x_file    , x_wave    , G_RUN_CREATE, "----" , "COND"  , "preparation"         , ""               , ""               , ""          , ""               , ""          , ""   , '-', '-', '-',   0,   0, '-', &x_cshare),    0);
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_nfile   ,   9)      , "   /*===[[ COND #001 ]]============================*/");
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_nfile   , 'о')      , "   yUNIT_cond    (   0, cyUNIT.offset +   1, '-', \"preparation\");");
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_nfile   , 'о')      , "(n/a)"                                      );
   yUNIT_mindnoc  ();

   yUNIT_mincond  ("verify writing an EXEC");
   yUNIT_minval   ("write code line"                    , CODE_exec      (x_nfile   , x_main    , x_file    , x_wave    , G_RUN_CREATE, "----", "exec"  , "call the function"   , "DITTO_parse"    , "x, y, 21"       , "s_equal"   , "pretty expected", "x_str"     , ""   , '-', '-', '-',   0,   0, '-', &x_cshare),    0);
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_nfile   , '┤')      , "      /*---(run step)--------------------*/"               );
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_nfile   , 'о')      , "      yUNIT_reset_rc ();"                                  );
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_nfile   , 'о')      , "      if (cyUNIT.exec)  cyUNIT.s_rc = DITTO_parse (x, y, 21);" );
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_nfile   , 'о')      , "      yUNIT_string  (   0,   1, \"call the function\", \"DITTO_parse\", \"x, y, 21\", \"s_equal\", \"pretty expected\", cyUNIT.s_rc, cyUNIT.exec);");
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_nfile   , 'о')      , "      if (cyUNIT.exec) { if (cyUNIT.s_rc != NULL)  strcpy (x_str, cyUNIT.s_rc); else strcpy (x_str, \"\"); }" );
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_nfile   , 'о')      , "(n/a)"                                    );
   yUNIT_mindnoc  ();

   yUNIT_mincond  ("verify writing another SCRP");
   yUNIT_minval   ("write code line"                    , CODE_scrp      (x_nfile   , x_main    , x_file    , x_wave    , G_RUN_CREATE, "----", "SCRP"  , "second layer"        , ""               , ""               , ""          , ""               , ""          , ""   , '-', '-', '-',   0,   0, '-', &x_cshare),    0);
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_nfile   ,  16)      , "      /*---(summary)---------------------*/");
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_nfile   , 'о')      , "      yUNIT_dnoc    (cyUNIT.exec);"         );
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_nfile   , 'о')      , "      /*---(done)------------------------*/");
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_nfile   , 'о')      , "   /*===[[ script done ]]==========================*/");
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_nfile   , 'о')      , "   yUNIT_prcs    (cyUNIT.exec);"            );
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_nfile   , 'о')      , "   /*---(complete)-----------------------*/");
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_nfile   , 'о')      , "   return 0;"                               );
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_nfile   , 'о')      , "}"                                          );
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_nfile   , 'о')      , ""                                           );
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_nfile   , 'о')      , "char"                                       );
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_nfile   , 'о')      , "yUNIT_script_02          (void)"            );
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_nfile   , 'о')      , "{"                                          );
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_nfile   , 'о')      , "   /*===[[ script header ]]========================*/");
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_nfile   , 'о')      , "   cyUNIT.offset  = 0;"                     );
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_nfile   , 'о')      , "   cyUNIT.origin  = 2;"                     );
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_nfile   , 'о')      , "   yUNIT_mode_reset ();"                    );
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_nfile   , 'о')      , "   yUNIT_scrp    (   0,   2, \"\", \"second layer\", \"\", \"\", \"\");");
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_nfile   , 'о')      , "(n/a)"                                      );
   yUNIT_mindnoc  ();

   yUNIT_mincond  ("verify writing to MAIN file)");
   yUNIT_minstr   ("... check MAIN"                     , yURG_upeek     (x_nmain   ,   0)   , "   if (yUNIT_run_scrp ( 1) == 1)  yUNIT_script_01 ();");
   yUNIT_minstr   ("... check MAIN"                     , yURG_upeek     (x_nmain   , 'о')   , "   if (yUNIT_run_scrp ( 2) == 1)  yUNIT_script_02 ();");
   yUNIT_minstr   ("... check MAIN"                     , yURG_upeek     (x_nmain   , 'о')   , "(n/a)"                                      );
   yUNIT_mindnoc  ();

   yUNIT_mincond  ("verify writing to WAVE file)");
   yUNIT_minstr   ("... check WAVE"                     , yURG_upeek     (x_nwave   ,  0 )   , "## ouroboros-aperantos (tail-eater) master unit testing sequencer");
   yUNIT_minstr   ("... check WAVE"                     , yURG_upeek     (x_nwave   , 'о')   , "## single unit test wave file");
   yUNIT_minstr   ("... check WAVE"                     , yURG_upeek     (x_nwave   , 'о')   , "##--  timestamp-----------------  epoch-----  project-------------  unit--------------------------  sc  S  description-----------------------------------------------------------  terse---------------  w  s  i  nun  nsc  nco  nstp  est  exp  R  pass  fail  badd  void  miss  act ");
   yUNIT_minstr   ("... check WAVE"                     , yURG_upeek     (x_nwave   , 'о')   , "WAVE  гг.гг.гг.гг.гг.гг.г.гг.ггг  гггггггггг  apate                 apate                            1  ¤  first testing                                                                                 0  a  и    0    1    1     1         0  -     0     0     0     0     1    0 ");
   yUNIT_minstr   ("... check WAVE"                     , yURG_upeek     (x_nwave   , 'о')   , "(n/a)"                                      );
   yUNIT_mindnoc  ();

   yUNIT_mincond  ("verify writing SHARED");
   yUNIT_minval   ("write code line"                    , CODE_shared    (x_nfile   , x_main    , x_file    , x_wave    , G_RUN_CREATE, "----", "SHARED", "some common data"    , ""               , ""               , ""          , ""               , ""          , ""   , '-', '-', '-',   0,   0, 'o', &x_cshare),    0);
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_nfile   ,  33)      , "   /*===[[ script done ]]==========================*/");
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_nfile   , 'о')      , "   yUNIT_prcs    (cyUNIT.exec);"            );
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_nfile   , 'о')      , "   /*---(complete)-----------------------*/");
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_nfile   , 'о')      , "   return 0;"                               );
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_nfile   , 'о')      , "}"                                          );
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_nfile   , 'о')      , ""                                           );
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_nfile   , 'о')      , "char"                                       );
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_nfile   , 'о')      , "yUNIT_shared_o           (void)"            );
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_nfile   , 'о')      , "{"                                          );
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_nfile   , 'о')      , "   /*===[[ shared header ]]========================*/");
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_nfile   , 'о')      , "   yUNIT_share ('o', \"some common data\");");
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_nfile   , 'о')      , "(n/a)"                                      );
   yUNIT_mindnoc  ();

   yUNIT_mincond  ("verify writing GLOBAL");
   yUNIT_minval   ("write code line"                    , CODE_global    (x_nfile   , x_main    , x_file    , x_wave    , G_RUN_CREATE, "----", "GLOBAL", "critical repeat"     , ""               , ""               , ""          , ""               , ""          , ""   , '-', '-', '-',   0,   0, 'J', &x_cshare),    0);
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_nfile   ,  44)      , "   /*===[[ shared done ]]==========================*/");
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_nfile   , 'о')      , "   yUNIT_erahs ('o');"                      );
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_nfile   , 'о')      , "   /*---(complete)-----------------------*/");
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_nfile   , 'о')      , "   return 0;"                               );
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_nfile   , 'о')      , "}"                                          );
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_nfile   , 'о')      , ""                                           );
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_nfile   , 'о')      , "char"                                       );
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_nfile   , 'о')      , "yUNIT_shared_J           (void)"            );
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_nfile   , 'о')      , "{"                                          );
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_nfile   , 'о')      , "   /*===[[ global header ]]========================*/");
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_nfile   , 'о')      , "   yUNIT_global ('J', \"critical repeat\");");
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_nfile   , 'о')      , "(n/a)"                                      );
   yUNIT_mindnoc  ();

   yUNIT_mincond  ("verify writing SECT");
   yUNIT_minval   ("write code line"                    , CODE_sect      (x_nfile   , x_main    , x_file    , x_wave    , G_RUN_CREATE, "----", "SECT"  , "later stuff"         , ""               , ""               , ""          , ""               , ""          , ""   , '-', '-', '-',   0,   0, '-', &x_cshare),    0);
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_nfile   ,  55)      , "   /*===[[ global done ]]==========================*/");
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_nfile   , 'о')      , "   yUNIT_labolg ('J');"                     );
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_nfile   , 'о')      , "   /*---(complete)-----------------------*/");
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_nfile   , 'о')      , "   return 0;"                               );
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_nfile   , 'о')      , "}"                                          );
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_nfile   , 'о')      , "(n/a)"                                      );
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_nfile   , 'о')      , "(n/a)"                                      );
   yUNIT_mindnoc  ();

   yUNIT_mincond  ("verify writing to MAIN file)");
   yUNIT_minstr   ("... check MAIN"                     , yURG_upeek     (x_nmain   ,   0)   , "   if (yUNIT_run_scrp ( 1) == 1)  yUNIT_script_01 ();");
   yUNIT_minstr   ("... check MAIN"                     , yURG_upeek     (x_nmain   , 'о')   , "   if (yUNIT_run_scrp ( 2) == 1)  yUNIT_script_02 ();");
   yUNIT_minstr   ("... check MAIN"                     , yURG_upeek     (x_nmain   , 'о')   , "   if (cyUNIT.all          == 1)  yUNIT_sect      (\"later stuff\");");
   yUNIT_minstr   ("... check MAIN"                     , yURG_upeek     (x_nmain   , 'о')   , "(n/a)"                                      );
   yUNIT_mindnoc  ();

   yUNIT_mincond  ("verify writing to WAVE file)");
   yUNIT_minstr   ("... check WAVE"                     , yURG_upeek     (x_nwave   ,  0 )   , "## ouroboros-aperantos (tail-eater) master unit testing sequencer");
   yUNIT_minstr   ("... check WAVE"                     , yURG_upeek     (x_nwave   , 'о')   , "## single unit test wave file");
   yUNIT_minstr   ("... check WAVE"                     , yURG_upeek     (x_nwave   , 'о')   , "##--  timestamp-----------------  epoch-----  project-------------  unit--------------------------  sc  S  description-----------------------------------------------------------  terse---------------  w  s  i  nun  nsc  nco  nstp  est  exp  R  pass  fail  badd  void  miss  act ");
   yUNIT_minstr   ("... check WAVE"                     , yURG_upeek     (x_nwave   , 'о')   , "WAVE  гг.гг.гг.гг.гг.гг.г.гг.ггг  гггггггггг  apate                 apate                            1  ¤  first testing                                                                                 0  a  и    0    1    1     1         0  -     0     0     0     0     1    0 ");
   yUNIT_minstr   ("... check WAVE"                     , yURG_upeek     (x_nwave   , 'о')   , "WAVE  гг.гг.гг.гг.гг.гг.г.гг.ггг  гггггггггг  apate                 apate                            2  ¤  second layer                                                                                  и  и  и    0    1    0     0         0  -     0     0     0     0     0    0 ");
   yUNIT_minstr   ("... check WAVE"                     , yURG_upeek     (x_nwave   , 'о')   , "(n/a)"                                      );
   yUNIT_mindnoc  ();

   yUNIT_mincond  ("open code file");
   yUNIT_minval   ("close the wave file"                , READ_close  (&x_wave)                 , 0);
   yUNIT_minval   ("close the code file"                , READ_close  (&x_file)                 , 0);
   yUNIT_minval   ("close the main file"                , READ_close  (&x_main)                 , 0);
   yUNIT_mindnoc  ();

   PROG__unit_end    ();
   sprintf (t, "rm -f %s 2> /dev/null", x_nmain);
   system (t);
   sprintf (t, "rm -f %s 2> /dev/null", x_nfile);
   system (t);
   sprintf (t, "rm -f %s 2> /dev/null", x_nwave);
   system (t);
   yUNIT_minprcs  ();
   return 0;
}

char
koios_code_cond    (void)
{
   char         x_name     [LEN_HUND] = "/tmp/apate.c";
   FILE        *x_main     = NULL;
   FILE        *x_file     = NULL;
   FILE        *x_wave     = NULL;
   char         x_cshare   =  '-';
   char         t          [LEN_HUND]  = "";

   yUNIT_minscrpy ("koios", "koios_code", "(CODE) verify condition level entries");
   PROG__unit_quiet  ();

   sprintf (t, "rm -f %s 2> /dev/null", x_name);
   system (t);
   yUNIT_mincond ("prepare clean start");
   yUNIT_minval   ("clear statistics"                   , CODE_init   (),    0);
   yUNIT_mindnoc ();

   yUNIT_mincond  ("open files");
   yUNIT_minval   ("open the main file"                 , READ_open   ("other"      , 'w', &x_main, NULL   ),    0);
   yUNIT_minval   ("open the code file"                 , READ_open   (x_name      , 'w', &x_file, NULL   ),    0);
   yUNIT_minval   ("open the wave file"                 , READ_open   ("wave"       , 'w', &x_wave, NULL   ),    0);
   yUNIT_mindnoc  ();

   yUNIT_mincond  ("verify writing a GROUP (before first COND)");
   yUNIT_minval   ("write code line"                    , CODE_group     (x_name    , x_main    , x_file    , x_wave    , G_RUN_CREATE, "----", "GROUP" , "up front"            , ""               , ""               , ""          , ""               , ""          , ""   , '-', '-', '-',   0,   0, '-', &x_cshare),    0);
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_name    ,   0)      , "   /*---(group)--------------------------*/");
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_name    , 'о')      , "   yUNIT_group   (\"up front\");"           );
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_name    , 'о')      , ""                                           );
   yUNIT_mindnoc  ();

   yUNIT_mincond  ("verify writing an COND");
   yUNIT_minval   ("write code line"                    , CODE_cond      (x_name    , x_main    , x_file    , x_wave    , G_RUN_CREATE, "----" , "COND"  , "preparation"         , ""               , ""               , ""          , ""               , ""          , ""   , '-', '-', '-',   0,   0, '-', &x_cshare),    0);
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_name    , '┤')      , "   /*===[[ COND #001 ]]============================*/");
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_name    , 'о')      , "   yUNIT_cond    (   0, cyUNIT.offset +   1, '-', \"preparation\");");
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_name    , 'о')      , ""                                           );
   yUNIT_mindnoc  ();

   yUNIT_mincond  ("verify writing a GROUP");
   yUNIT_minval   ("write code line"                    , CODE_group     (x_name    , x_main    , x_file    , x_wave    , G_RUN_CREATE, "----" , "GROUP" , "little stuff"        , ""               , ""               , ""          , ""               , ""          , ""   , '-', '-', '-',   0,   0, '-', &x_cshare),    0);
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_name    , '┤')      , "      /*---(summary)---------------------*/");
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_name    , 'о')      , "      yUNIT_dnoc    (cyUNIT.exec);"         );
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_name    , 'о')      , "      /*---(done)------------------------*/");
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_name    , 'о')      , "   /*---(group)--------------------------*/");
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_name    , 'о')      , "   yUNIT_group   (\"little stuff\");");
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_name    , 'о')      , ""                                           );
   yUNIT_mindnoc  ();

   yUNIT_mincond  ("verify writing a REUSE");
   yUNIT_minval   ("write code line"                    , CODE_reuse     (x_name    , x_main    , x_file    , x_wave    , G_RUN_CREATE, "GROUP", "REUSE" , "little stuff"        , ""               , ""               , ""          , ""               , ""          , ""   , '-', '-', '-',   0,   0, 'd', &x_cshare),    0);
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_name    , '┤')      , "   /*---(shared code)--------------------*/");
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_name    , 'о')      , "   cyUNIT.offset = 1;"                      );
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_name    , 'о')      , "   yUNIT_shared_d ();"                      );
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_name    , 'о')      , "   cyUNIT.offset = 0;"                      );
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_name    , 'о')      , ""                                           );
   yUNIT_mindnoc  ();

   yUNIT_mincond  ("open code file");
   yUNIT_minval   ("close the wave file"                , READ_close  (&x_wave)                 , 0);
   yUNIT_minval   ("close the code file"                , READ_close  (&x_file)                 , 0);
   yUNIT_minval   ("close the main file"                , READ_close  (&x_main)                 , 0);
   yUNIT_mindnoc  ();

   PROG__unit_end    ();
   yUNIT_minprcs  ();
   return 0;
}

char
koios_code_steps   (void)
{
   char         x_name     [LEN_HUND] = "/tmp/apate.c";
   FILE        *x_main     = NULL;
   FILE        *x_file     = NULL;
   FILE        *x_wave     = NULL;
   char         x_cshare   =  '-';
   char         t          [LEN_HUND]  = "";

   yUNIT_minscrpy ("koios", "koios_code", "(CODE) verify step level entries");
   PROG__unit_quiet  ();

   sprintf (t, "rm -f %s 2> /dev/null", x_name);
   system (t);
   yUNIT_mincond ("prepare clean start");
   yUNIT_minval   ("clear statistics"                   , CODE_init   (),    0);
   yUNIT_mindnoc ();

   yUNIT_mincond  ("open files");
   yUNIT_minval   ("open the main file"                 , READ_open   ("other"     , 'w', &x_main, NULL   ),    0);
   yUNIT_minval   ("open the code file"                 , READ_open   (x_name      , 'w', &x_file, NULL   ),    0);
   yUNIT_minval   ("open the wave file"                 , READ_open   ("wave"      , 'w', &x_wave, NULL   ),    0);
   yUNIT_mindnoc  ();

   yUNIT_mincond  ("verify writing an EXEC");
   yUNIT_minval   ("write code line"                    , CODE_exec      (x_name    , x_main    , x_file    , x_wave    , G_RUN_CREATE, "----", "exec"  , "call the function"   , "DITTO_parse"    , "x, y, 21"       , "s_equal"   , "pretty expected", "x_str"     , ""   , '-', '-', '-',   0,   0, '-', &x_cshare),    0);
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_name    ,   0)      , "      /*---(run step)--------------------*/"               );
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_name    , 'о')      , "      yUNIT_reset_rc ();"                                  );
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_name    , 'о')      , "      if (cyUNIT.exec)  cyUNIT.s_rc = DITTO_parse (x, y, 21);" );
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_name    , 'о')      , "      yUNIT_string  (   0,   1, \"call the function\", \"DITTO_parse\", \"x, y, 21\", \"s_equal\", \"pretty expected\", cyUNIT.s_rc, cyUNIT.exec);");
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_name    , 'о')      , "      if (cyUNIT.exec) { if (cyUNIT.s_rc != NULL)  strcpy (x_str, cyUNIT.s_rc); else strcpy (x_str, \"\"); }" );
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_name    , 'о')      , ""                                         );
   yUNIT_mindnoc  ();

   yUNIT_mincond  ("verify writing an EXEC (in debug)");
   yUNIT_minval   ("write code line"                    , CODE_exec      (x_name    , x_main    , x_file    , x_wave    , G_RUN_DEBUG , "----", "exec"  , "call the function"   , "DITTO_parse"    , "x, y, 21"       , "s_equal"   , "pretty expected", "x_str"     , ""   , '-', '-', '-',   0,   0, '-', &x_cshare),    0);
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_name    , '┤')      , "      /*---(run step)--------------------*/"               );
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_name    , 'о')      , "      DEBUG_PROG    yLOG_unitstep (cyUNIT.origin, cyUNIT.offset +   0,   2,    0, \"call the function\");" );
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_name    , 'о')      , "      yUNIT_reset_rc ();"                                  );
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_name    , 'о')      , "      if (cyUNIT.exec)  cyUNIT.s_rc = DITTO_parse (x, y, 21);" );
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_name    , 'о')      , "      yUNIT_string  (   0,   2, \"call the function\", \"DITTO_parse\", \"x, y, 21\", \"s_equal\", \"pretty expected\", cyUNIT.s_rc, cyUNIT.exec);");
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_name    , 'о')      , "      if (cyUNIT.exec) { if (cyUNIT.s_rc != NULL)  strcpy (x_str, cyUNIT.s_rc); else strcpy (x_str, \"\"); }" );
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_name    , 'о')      , ""                                         );
   yUNIT_mindnoc  ();

   yUNIT_mincond  ("verify writing an ECHO");
   yUNIT_minval   ("write code line"                    , CODE_exec      (x_name    , x_main    , x_file    , x_wave    , G_RUN_CREATE, "----", "echo"  , "check key variable"  , ""               , "x_var"          , "i_equal"   , "27"             , ""          , ""   , '-', '-', '-',   0,   0, '-', &x_cshare),    0);
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_name    , '┤')      , "      /*---(echo to verify)--------------*/"               );
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_name    , 'о')      , "      yUNIT_int     (   0,   3, \"check key variable\", \"\", \"x_var\", \"i_equal\", 27, x_var, cyUNIT.exec);");
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_name    , 'о')      , ""                                         );
   yUNIT_mindnoc  ();

   yUNIT_mincond  ("verify writing a GET");
   yUNIT_minval   ("write code line"                    , CODE_exec      (x_name    , x_main    , x_file    , x_wave    , G_RUN_CREATE, "----", "get"   , "verify result"       , "DITTO__unit"    , "15"             , "s_equal"   , "test string"    , ""          , ""   , '-', '-', '-',   0,   0, '-', &x_cshare),    0);
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_name    , '┤')      , "      /*---(check result)----------------*/"               );
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_name    , 'о')      , "      yUNIT_reset_rc ();"                                  );
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_name    , 'о')      , "      if (cyUNIT.exec)  cyUNIT.s_rc = DITTO__unit (15);" );
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_name    , 'о')      , "      yUNIT_string  (   0,   4, \"verify result\", \"DITTO__unit\", \"15\", \"s_equal\", \"test string\", cyUNIT.s_rc, cyUNIT.exec);");
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_name    , 'о')      , ""                                         );
   yUNIT_mindnoc  ();

   yUNIT_mincond  ("open code file");
   yUNIT_minval   ("close the wave file"                , READ_close  (&x_wave)                 , 0);
   yUNIT_minval   ("close the code file"                , READ_close  (&x_file)                 , 0);
   yUNIT_minval   ("close the main file"                , READ_close  (&x_main)                 , 0);
   yUNIT_mindnoc  ();

   PROG__unit_end    ();
   yUNIT_minprcs  ();
   return 0;
}

char
koios_code_vars    (void)
{
   char         x_name     [LEN_HUND] = "/tmp/apate.c";
   FILE        *x_main     = NULL;
   FILE        *x_file     = NULL;
   FILE        *x_wave     = NULL;
   char         x_cshare   =  '-';
   char         t          [LEN_HUND]  = "";

   yUNIT_minscrpy ("koios", "koios_code", "(CODE) verify variable entries");
   PROG__unit_quiet  ();

   sprintf (t, "rm -f %s 2> /dev/null", x_name);
   system (t);
   yUNIT_mincond ("prepare clean start");
   yUNIT_minval   ("clear statistics"                   , CODE_init   (),    0);
   yUNIT_mindnoc ();

   yUNIT_mincond  ("open files");
   yUNIT_minval   ("open the main file"                 , READ_open   ("other"     , 'w', &x_main, NULL   ),    0);
   yUNIT_minval   ("open the code file"                 , READ_open   (x_name      , 'w', &x_file, NULL   ),    0);
   yUNIT_minval   ("open the wave file"                 , READ_open   ("wave"      , 'w', &x_wave, NULL   ),    0);
   yUNIT_mindnoc  ();

   yUNIT_mincond  ("verify writing an global variable");
   yUNIT_minval   ("write code line"                    , CODE_gvar      (x_name    , x_main    , x_file    , x_wave    , G_RUN_CREATE, "----", "global", "working variable"    , ""               , ""               , ""          , "int g_var = 42;", ""          , ""   , '-', '-', '-',   0,   0, '-', &x_cshare),    0);
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_name    ,   0)      , "/*---(global variable)-------------*/"                     );
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_name    , 'о')      , "int g_var = 42;"                                           );
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_name    , 'о')      , ""                                         );
   yUNIT_mindnoc  ();

   yUNIT_mincond  ("verify writing a local variable");
   yUNIT_minval   ("write code line"                    , CODE_lvar      (x_name    , x_main    , x_file    , x_wave    , G_RUN_CREATE, "----", "local" , "return variable"     , ""               , ""               , ""          , "char x_var = 0;", ""          , ""   , '-', '-', '-',   0,   0, '-', &x_cshare),    0);
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_name    ,   2)      , "      /*---(local variable)--------------*/"               );
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_name    , 'о')      , "      yUNIT_local   (   0,   2, \"return variable\", \"char x_var = 0;\", cyUNIT.exec);");
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_name    , 'о')      , "      char x_var = 0;"                                     );
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_name    , 'о')      , ""                                         );
   yUNIT_mindnoc  ();

   yUNIT_mincond  ("verify writing a CODE");
   yUNIT_minval   ("write code line"                    , CODE_code      (x_name    , x_main    , x_file    , x_wave    , G_RUN_CREATE, "----", "code"  , "add variables"       , ""               , ""               , ""          , "a = xк + yк;"   , ""          , ""   , '-', '-', '-',   0,   0, '-', &x_cshare),    0);
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_name    ,   5)      , "      /*---(inject code)-----------------*/"               );
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_name    , 'о')      , "      yUNIT_code    (   0,   3, \"add variables\", \"a = xк + yк;\", cyUNIT.exec);");
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_name    , 'о')      , "      if (cyUNIT.exec) { a = xк + yк; }"                                        );
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_name    , 'о')      , ""                                         );
   yUNIT_mindnoc  ();

   yUNIT_mincond  ("open code file");
   yUNIT_minval   ("close the script file"              , READ_close  (&x_file)                 , 0);
   yUNIT_mindnoc  ();

   PROG__unit_end    ();
   yUNIT_minprcs  ();
   return 0;
}

char
koios_code_spec    (void)
{
   char         x_name     [LEN_HUND] = "/tmp/apate.c";
   FILE        *x_main     = NULL;
   FILE        *x_file     = NULL;
   FILE        *x_wave     = NULL;
   char         x_cshare   =  '-';
   char         t          [LEN_HUND]  = "";

   yUNIT_minscrpy ("koios", "koios_code", "(CODE) verify specialty entries");
   PROG__unit_quiet  ();

   sprintf (t, "rm -f %s 2> /dev/null", x_name);
   system (t);
   yUNIT_mincond ("prepare clean start");
   yUNIT_minval   ("clear statistics"                   , CODE_init   (),    0);
   yUNIT_mindnoc ();

   yUNIT_mincond  ("open files");
   yUNIT_minval   ("open the main file"                 , READ_open   ("other"     , 'w', &x_main, NULL   ),    0);
   yUNIT_minval   ("open the code file"                 , READ_open   (x_name      , 'w', &x_file, NULL   ),    0);
   yUNIT_minval   ("open the wave file"                 , READ_open   ("wave"      , 'w', &x_wave, NULL   ),    0);
   yUNIT_mindnoc  ();

   yUNIT_mincond  ("verify writing a LOAD");
   yUNIT_minval   ("write code line"                    , CODE_load      (x_name    , x_main    , x_file    , x_wave    , G_RUN_CREATE, "----", "load"  , "prepare stdin"       , "stdin"          , ""               , ""          , "shove this"     , ""          , ""   , '-', '-', '-',   0,   0, '-', &x_cshare),    0);
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_name    ,   0)      , "      /*---(load input)------------------*/"               );
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_name    , 'о')      , "      yUNIT_load    (   0,   1, \"prepare stdin\", \"stdin\", \"shove this\", cyUNIT.exec);");
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_name    , 'о')      , ""                                         );
   yUNIT_mindnoc  ();

   yUNIT_mincond  ("verify writing a MODE");
   yUNIT_minval   ("write code line"                    , CODE_mode      (x_name    , x_main    , x_file    , x_wave    , G_RUN_CREATE, "----", "mode"  , "FORCED_FAIL"         , ""               , ""               , ""          , ""               , ""          , ""   , '-', '-', '-',   0,   0, '-', &x_cshare),    0);
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_name    , '┤')      , "      /*---(unit test mode)--------------*/"               );
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_name    , 'о')      , "      yUNIT_mode    (   0,   2, \"FORCED_FAIL\", cyUNIT.exec);");
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_name    , 'о')      , ""                                         );
   yUNIT_mindnoc  ();

   yUNIT_mincond  ("verify writing a SYSTEM");
   yUNIT_minval   ("write code line"                    , CODE_system    (x_name    , x_main    , x_file    , x_wave    , G_RUN_CREATE, "----", "system", "check directory"     , ""               , ""               , ""          , "ls -l"          , ""          , ""   , '-', '-', '-',   0,   0, '-', &x_cshare),    0);
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_name    , '┤')      , "      /*---(system command)--------------*/"               );
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_name    , 'о')      , "      yUNIT_system  (   0,   3, \"check directory\", \"ls -l\", \"ls -l\", cyUNIT.exec);");
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_name    , 'о')      , ""                                         );
   yUNIT_mindnoc  ();

   yUNIT_mincond  ("verify writing a FILE");
   yUNIT_minval   ("write code line"                    , CODE_file      (x_name    , x_main    , x_file    , x_wave    , G_RUN_CREATE, "----", "file"  , "testing file"        , ""               , ""               , ""          , "test.txt"       , ""          , ""   , '-', '-', '-',   0,   0, '-', &x_cshare),    0);
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_name    , '┤')      , "      /*---(create test file)------------*/"               );
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_name    , 'о')      , "      yUNIT_file    (   0,   4, \"testing file\", \"test.txt\", cyUNIT.exec);");
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_name    , 'о')      , ""                                         );
   yUNIT_mindnoc  ();

   yUNIT_mincond  ("verify writing an APPEND");
   yUNIT_minval   ("write code line"                    , CODE_append    (x_name    , x_main    , x_file    , x_wave    , G_RUN_CREATE, "----", "append", "add a line"          , ""               , ""               , ""          , "hello world"    , ""          , ""   , '-', '-', '-',   0,   0, '-', &x_cshare),    0);
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_name    , '┤')      , "      /*---(append test file)------------*/"               );
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_name    , 'о')      , "      yUNIT_append  (   0,   5, \"add a line\", \"hello world\", cyUNIT.exec);");
   yUNIT_minstr   ("... check result"                   , yURG_upeek     (x_name    , 'о')      , ""                                         );
   yUNIT_mindnoc  ();

   yUNIT_mincond  ("open code file");
   yUNIT_minval   ("close the wave file"                , READ_close  (&x_wave)                 , 0);
   yUNIT_minval   ("close the code file"                , READ_close  (&x_file)                 , 0);
   yUNIT_minval   ("close the main file"                , READ_close  (&x_main)                 , 0);
   yUNIT_mindnoc  ();

   PROG__unit_end    ();
   yUNIT_minprcs  ();
   return 0;
}

char
koios_code_driver  (void)
{
   char         x_name     [LEN_HUND]  = "/tmp/apate.unit";
   char         t          [LEN_HUND]  = "";
   FILE        *x_file     = NULL;
   char         x_cshare   =  '-';

   yUNIT_minscrpy ("koios", "koios_code", "(CODE) verify main code driver");
   PROG__unit_quiet  ();


   PROG__unit_end    ();
   yUNIT_minprcs  ();
   return 0;
}

char
main                    (void)
{
   koios_code_display  ();
   koios_code_prefix   ();
   koios_code_expect   ();
   koios_code_suffix   ();
   koios_code_preps    ();
   koios_code_scrp     ();
   koios_code_cond     ();
   koios_code_steps    ();
   koios_code_vars     ();
   koios_code_spec     ();
   koios_code_driver   ();
   yUNIT_mintinu    ();
   return 0;
}

